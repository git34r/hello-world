<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bon - Interactive Ball</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.z = 5;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.canvas);
        
        // Lighting - increased brightness
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight2.position.set(-5, 5, -5);
        scene.add(directionalLight2);
        
        const pointLight = new THREE.PointLight(0xffffff, 0.8);
        pointLight.position.set(0, 0, 5);
        scene.add(pointLight);
        
        // Create sphere
        const geometry = new THREE.SphereGeometry(1.5, 64, 64);
        
        // Create material first (will show white if texture fails)
        const material = new THREE.MeshStandardMaterial({
            color: 0xffffff, // Fallback color if texture fails
            roughness: 0.3,
            metalness: 0.1
        });
        
        // Load texture with error handling
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(
            'port/BonpitDallaniel.png',
            (loadedTexture) => {
                // Texture loaded successfully
                loadedTexture.wrapS = THREE.RepeatWrapping;
                loadedTexture.wrapT = THREE.RepeatWrapping;
                loadedTexture.repeat.set(1, 1);
                material.map = loadedTexture;
                material.needsUpdate = true;
                console.log('Texture loaded successfully');
            },
            undefined,
            (error) => {
                console.error('Error loading texture:', error);
                console.log('Using fallback white material');
                // Material will use the white color we set above
            }
        );
        
        const ball = new THREE.Mesh(geometry, material);
        scene.add(ball);
        
        // Initial render to make sure something shows up
        renderer.render(scene, camera);
        
        // Debug info
        console.log('Scene initialized');
        console.log('Ball created at position:', ball.position);
        console.log('Camera position:', camera.position);
        console.log('Renderer size:', renderer.getSize(new THREE.Vector2()));
        
        // Rotation state
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationVelocity = { x: 0, y: 0 };
        const friction = 0.95; // Controls how fast it slows down
        const sensitivity = 0.01; // Controls rotation speed
        
        // Mouse events
        let mouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        renderer.domElement.addEventListener('mousedown', (event) => {
            mouseDown = true;
            isDragging = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
            rotationVelocity.x = 0;
            rotationVelocity.y = 0;
        });
        
        renderer.domElement.addEventListener('mousemove', (event) => {
            if (mouseDown && isDragging) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;
                
                // Apply rotation
                ball.rotation.y += deltaX * sensitivity;
                ball.rotation.x += deltaY * sensitivity;
                
                // Update velocity for momentum
                rotationVelocity.y = deltaX * sensitivity * 0.5;
                rotationVelocity.x = deltaY * sensitivity * 0.5;
                
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        });
        
        renderer.domElement.addEventListener('mouseup', () => {
            mouseDown = false;
            isDragging = false;
        });
        
        renderer.domElement.addEventListener('mouseleave', () => {
            mouseDown = false;
            isDragging = false;
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Apply momentum when not dragging
            if (!isDragging) {
                ball.rotation.y += rotationVelocity.y;
                ball.rotation.x += rotationVelocity.x;
                
                // Apply friction for smooth deceleration
                rotationVelocity.y *= friction;
                rotationVelocity.x *= friction;
                
                // Stop very small movements
                if (Math.abs(rotationVelocity.y) < 0.001) rotationVelocity.y = 0;
                if (Math.abs(rotationVelocity.x) < 0.001) rotationVelocity.x = 0;
            }
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>

