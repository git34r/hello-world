<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bon - Interactive Ball</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Sora:wght@100..800&display=swap');
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000000;
            font-family: 'Sora', sans-serif;
            margin: 0;
            padding: 0;
            position: relative;
        }
        
        #top-dock {
            position: fixed;
            top: 24px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 28px;
            display: flex;
            align-items: center;
            gap: 22px;
            background: rgba(0, 0, 0, 0.65);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 999px;
            z-index: 250;
        }
        
        #top-dock a {
            font-size: 13px;
            font-weight: 500;
            letter-spacing: 1px;
            text-decoration: none;
            text-transform: lowercase;
            color: #ffffff;
            opacity: 0.75;
            transition: opacity 0.2s ease;
        }
        
        #top-dock a:hover {
            opacity: 1;
        }
        
        #bonpit-title {
            position: fixed;
            left: 40px;
            top: 50%;
            transform: translateY(-50%);
            font-family: 'Sora', sans-serif;
            font-size: 18px;
            font-weight: 300;
            color: #ffffff;
            letter-spacing: 0.5px;
            text-transform: lowercase;
            z-index: 200;
            pointer-events: none;
        }
        
        #bonpit-bio {
            position: fixed;
            right: 20px;
            bottom: 0;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-family: 'Sora', sans-serif;
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            line-height: 1.4;
            max-width: 1200px;
            max-height: 50vh;
            z-index: 200;
            pointer-events: none;
            white-space: pre-line;
            padding-bottom: 0;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        #motion-blur-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            /* Use mask to only blur the edges */
            mask: radial-gradient(ellipse at center, transparent 30%, black 60%);
            -webkit-mask: radial-gradient(ellipse at center, transparent 30%, black 60%);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            opacity: 0.8;
        }
        
        /* Fallback for browsers without backdrop-filter - just use darkening */
        @supports not (backdrop-filter: blur(1px)) {
            #motion-blur-overlay {
                background: radial-gradient(ellipse at center, transparent 0%, transparent 30%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.5) 70%, rgba(0, 0, 0, 0.8) 100%);
                mask: none;
                -webkit-mask: none;
            }
        }
        
    </style>
</head>
<body>
    <nav id="top-dock">
        <a href="https://bonpit.com/releases" target="_blank" rel="noopener">releases</a>
        <a href="https://bonpit.com/vapestream" target="_blank" rel="noopener">watch vapemodel</a>
        <a href="https://bonpit.com/portfolio" target="_blank" rel="noopener">portfolio</a>
        <a href="mailto:admin@bonpit.com">contact</a>
    </nav>
    <div id="bonpit-title">bonpit</div>
    <div id="bonpit-bio">Widespread and foolhardy: genrexpermintal. Bonpit is 23 year old Artist active as Producer, DJ and Designer from Germany. Out of his world ranging from bounding trance to reckless club music, he always tries to extend the limits and outdo hisself.</div>
    <div id="motion-blur-overlay"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <script>
        // Check if Three.js loaded
        if (typeof THREE === 'undefined') {
            console.error('Three.js failed to load');
            document.body.innerHTML = '<div style="color: white; padding: 20px;">Error: Three.js failed to load. Please check your internet connection.</div>';
        } else {
            console.log('Three.js loaded successfully');
        }
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // Black background
        
        const camera = new THREE.PerspectiveCamera(
            100,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.z = 3;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        
        console.log('Renderer created, canvas added to body');
        console.log('Canvas dimensions:', renderer.domElement.width, renderer.domElement.height);
        
        // Verify motion blur overlay exists
        const blurOverlay = document.getElementById('motion-blur-overlay');
        if (blurOverlay) {
            console.log('Motion blur overlay found and active');
        } else {
            console.error('Motion blur overlay not found!');
        }
        
        // Motion blur effect is handled via CSS on the overlay element
        
        // Lighting - main light from top right back
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        // Main directional light from top right back
        const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
        mainLight.position.set(5, 5, -5); // Top right back
        scene.add(mainLight);
        
        // Subtle fill light from opposite side
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
        fillLight.position.set(-3, 2, 3);
        scene.add(fillLight);
        
        // Soft light from the front
        const frontLight = new THREE.DirectionalLight(0xffffff, 0.6);
        frontLight.position.set(0, 0, 5); // Front
        scene.add(frontLight);
        
        // Load GLB model
        let model = null;
        
        // Wait a bit for GLTFLoader to load if needed
        setTimeout(function() {
            if (typeof THREE.GLTFLoader === 'undefined') {
                console.error('GLTFLoader not available');
                return;
            }
            
            const loader = new THREE.GLTFLoader();
            const modelUrl = 'https://raw.githubusercontent.com/git34r/hello-world/main/port/bonpitbluekey.glb';
            
            loader.load(
                modelUrl,
                function(gltf) {
                    const originalModel = gltf.scene;
                    
                    // Remove small objects first - find the main object and remove small ones
                    const allObjects = [];
                    originalModel.traverse(function(child) {
                        if (child.isMesh) {
                            const box = new THREE.Box3().setFromObject(child);
                            const size = box.getSize(new THREE.Vector3());
                            const maxSize = Math.max(size.x, size.y, size.z);
                            allObjects.push({ child: child, size: maxSize });
                        }
                    });
                    
                    // Find the largest object (main object)
                    if (allObjects.length > 0) {
                        allObjects.sort((a, b) => b.size - a.size);
                        const mainObjectSize = allObjects[0].size;
                        
                        // Remove objects that are significantly smaller (less than 20% of main object)
                        allObjects.forEach(function(obj) {
                            if (obj.size < mainObjectSize * 0.2) {
                                // Remove small object
                                if (obj.child.parent) {
                                    obj.child.parent.remove(obj.child);
                                }
                            }
                        });
                    }
                    
                    // Calculate bounding box to find center and size AFTER removing small objects
                    const box = new THREE.Box3().setFromObject(originalModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    
                    // Create a group to hold the model - rotation will happen around group's origin
                    const modelGroup = new THREE.Group();
                    scene.add(modelGroup);
                    
                    // Scale to fit nicely in view - make it bigger for up-close spectating feel
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 4.5 / maxDim;
                    originalModel.scale.multiplyScalar(scale);
                    
                    // Recalculate center after scaling to ensure proper centering
                    const boxAfterScale = new THREE.Box3().setFromObject(originalModel);
                    const centerAfterScale = boxAfterScale.getCenter(new THREE.Vector3());
                    
                    // Center the model by translating it so its center is at the group's origin (0,0,0)
                    originalModel.position.x = -centerAfterScale.x;
                    originalModel.position.y = -centerAfterScale.y;
                    originalModel.position.z = -centerAfterScale.z;
                    
                    // Add the centered and scaled model to the group
                    modelGroup.add(originalModel);
                    
                    // Remove normal maps/textures from all materials
                    originalModel.traverse(function(child) {
                        if (child.isMesh && child.material) {
                            // Handle both single materials and arrays
                            const materials = Array.isArray(child.material) ? child.material : [child.material];
                            materials.forEach(function(material) {
                                if (material.normalMap) {
                                    material.normalMap = null;
                                    material.needsUpdate = true;
                                }
                            });
                        }
                    });
                    
                    // Verify final center is at origin
                    const finalBox = new THREE.Box3().setFromObject(modelGroup);
                    const finalCenter = finalBox.getCenter(new THREE.Vector3());
                    console.log('Final center after all transformations:', finalCenter);
                    
                    // Update model reference to the group for rotation
                    model = modelGroup;
                    
                    console.log('GLB model loaded successfully');
                },
                function(xhr) {
                    if (xhr.lengthComputable) {
                        console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    }
                },
                function(error) {
                    console.error('Error loading GLB model:', error);
                }
            );
        }, 100);
        
        // Initial render
        renderer.render(scene, camera);
        console.log('Initial render complete');
        
        // Rotation state
        let isDragging = false;
        let rotationVelocity = { x: 0, y: 0 };
        const friction = 0.95;
        const sensitivity = 0.01;
        
        // Floating/wiggling motion state
        const centerPosition = new THREE.Vector3(0, 0, 0);
        let floatVelocity = new THREE.Vector3(0, 0, 0);
        const magneticStrength = 0.04; // How strong the pull to center is (increased)
        const wiggleStrength = 0.0015; // How much random wiggle (increased)
        const damping = 0.95; // Air resistance for floating motion
        let time = 0;
        
        // Hover and pulse state
        let isHovering = false;
        let pulseTime = 0;
        const baseScale = 1.0;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Mouse events
        let mouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        renderer.domElement.addEventListener('mousedown', function(event) {
            mouseDown = true;
            isDragging = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
            rotationVelocity.x = 0;
            rotationVelocity.y = 0;
        });
        
        renderer.domElement.addEventListener('mousemove', function(event) {
            // Update mouse position for hover detection
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Check if hovering over model
            if (model && model.children[0]) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(model.children[0], true);
                
                if (intersects.length > 0 && !mouseDown) {
                    if (!isHovering) {
                        isHovering = true;
                        pulseTime = 0; // Reset pulse when starting to hover
                    }
                } else {
                    isHovering = false;
                }
            }
            
            if (mouseDown && isDragging && model) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;
                
                // Apply rotation
                model.rotation.y += deltaX * sensitivity;
                model.rotation.x += deltaY * sensitivity;
                
                // Update velocity for momentum
                rotationVelocity.y = deltaX * sensitivity * 0.5;
                rotationVelocity.x = deltaY * sensitivity * 0.5;
                
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            } else {
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        });
        
        renderer.domElement.addEventListener('mouseup', function() {
            mouseDown = false;
            isDragging = false;
        });
        
        renderer.domElement.addEventListener('mouseleave', function() {
            mouseDown = false;
            isDragging = false;
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.01;
            
            // Apply momentum when not dragging
            if (!isDragging && model) {
                model.rotation.y += rotationVelocity.y;
                model.rotation.x += rotationVelocity.x;
                
                // Apply friction for smooth deceleration
                rotationVelocity.y *= friction;
                rotationVelocity.x *= friction;
                
                // Stop very small movements
                if (Math.abs(rotationVelocity.y) < 0.001) rotationVelocity.y = 0;
                if (Math.abs(rotationVelocity.x) < 0.001) rotationVelocity.x = 0;
            }
            
            // Floating/wiggling motion - magnetic to center with space-like wiggle
            if (model) {
                // Get the actual model mesh from the group (first child)
                const modelMesh = model.children[0];
                if (modelMesh) {
                    const currentPos = model.position.clone();
                    const toCenter = centerPosition.clone().sub(currentPos);
                    
                    // Magnetic pull toward center
                    floatVelocity.add(toCenter.multiplyScalar(magneticStrength));
                    
                    // Add wiggly motion using sine waves for smooth, organic movement
                    floatVelocity.x += Math.sin(time * 1.3) * wiggleStrength;
                    floatVelocity.y += Math.cos(time * 1.7) * wiggleStrength;
                    floatVelocity.z += Math.sin(time * 1.1) * wiggleStrength;
                    
                    // Apply damping (air resistance in space)
                    floatVelocity.multiplyScalar(damping);
                    
                    // Update position
                    model.position.add(floatVelocity);
                    
                    // Limit maximum distance from center (soft boundary)
                    const distanceFromCenter = model.position.length();
                    if (distanceFromCenter > 0.3) {
                        const pullBack = model.position.clone().normalize().multiplyScalar(-0.01);
                        floatVelocity.add(pullBack);
                    }
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start animation
        animate();
        console.log('Animation started');
    </script>
</body>
</html>

